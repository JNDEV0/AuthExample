# ACTION: Create .NET 8 Identity Ecosystem Solution
# ARCHITECTURE: Vertical Slice Architecture (VSA) with REPR Pattern (Minimal APIs) for APIs
# FRONTEND: ASP.NET Core MVC + HTMX + Wireframe CSS System for WebApp

## STEP 1: SOLUTION SCAFFOLDING & INFRASTRUCTURE
1. Create a root solution named "Net8IdentityEco".
2. Create three projects with specific "launchSettings.json" profiles:
   - "AuthServer" (ASP.NET Core Web API): Port https://localhost:5001.
   - "WebApp" (ASP.NET Core MVC): Port https://localhost:5002.
   - "ResourceApi" (ASP.NET Core Web API): Port https://localhost:5003.
3. Enforce HTTPS: Run "dotnet dev-certs https --trust".
4. Architecture Constraint: "AuthServer" and "ResourceApi" must strictly adhere to Vertical Slice Architecture. Do NOT use traditional Controllers for these two projects. Group code by Feature (e.g., Features/Identity/Login). All endpoints must use Minimal APIs implementing the REPR pattern (Request-Endpoint-Response). The "WebApp" will remain standard MVC with Controllers.

## STEP 2: DATA LAYER & OPENIDDICT CORE (AuthServer)
1. Install OpenIddict.AspNetCore, OpenIddict.EntityFrameworkCore, OpenIddict.Quartz, and Microsoft.EntityFrameworkCore.Sqlite.
2. Create "ApplicationDbContext" inheriting "IdentityDbContext" using SQLite.
   - Add a custom "DateOfBirth" property to "ApplicationUser".
   - In "OnModelCreating", call "builder.UseOpenIddict()" to register entities (Applications, Authorizations, Scopes, Tokens).
3. Configure OpenIddict in "Program.cs":
   - Enable Authorization Code Flow with PKCE.
   - Enable Refresh Token Flow.
   - Register scopes ("email", "profile", "roles", "resource_api").
   - Use Reference Access Tokens.
   - Integrate Quartz.NET ("AddQuartz", "UseQuartz()") for scheduled token pruning.
   - Set Encryption/Signing keys (Ephemeral for Dev).
4. Run EF Core Migrations ("Add-Migration InitialCreate") to generate the SQLite database.

## STEP 3: SECURITY MIDDLEWARE & BOT PROTECTION (AuthServer)
1. Enable Session Middleware ("AddSession", "UseSession").
2. Implement "TurnstileMiddleware":
   - Intercept requests to "/connect/authorize".
   - Check for a Session String "CloudflareVerified".
   - If missing, interrupt the pipeline and return a raw HTML/Razor response (simulating "Cloudflare.cshtml") containing a Cloudflare Turnstile widget.
   - The page must NOT have its own 'Confirm' button; the widget must trigger the form post automatically upon solution.
   - Crucial: Display the "Ray ID" sourced from the request headers (or HttpContext.TraceIdentifier if local) under the captcha widget.
3. Implement the verification logic:
   - On widget success, POST to a local endpoint that sets the "CloudflareVerified" session flag and redirects back to the original "/connect/authorize" URL.

## STEP 4: IDENTITY FEATURE SLICES (AuthServer)
Implement the following features using VSA/Minimal APIs. Use "IDataProtectionProvider" for state management (do NOT use JWTs for this local state).

**Slice A: Features/Identity/CheckEmail**
- Input: Email.
- Logic: Check if user exists.
- Output: A "DataProtectionToken" encrypted with purpose string "Authentication.Login.Challenge:{Email}".
- CORS: Enable specifically for WebApp origin (https://localhost:5002).

**Slice B: Features/Identity/Login**
- Input: Email, Password, ChallengeToken.
- Logic:
  1. Unprotect and validate the ChallengeToken. Ensure it matches the email and is not expired (5 min limit).
  2. If valid, use "SignInManager.CheckPasswordSignInAsync".
  3. If success, call "SignInManager.SignInAsync" (creates Identity Cookie) and return 200 OK.
  4. Response must instruct client to redirect to the original "/connect/authorize" URL.

**Slice C: Features/Identity/Register (Multi-Step Secure Flow)**
- Endpoint 1: "/register-start"
  - Input: Email, DateOfBirth, TermsAccepted.
  - Logic:
    - Check if email exists.
    - If Exists: Send "Account already exists" email with password reset link. Do NOT alert client.
    - If New: Send Confirmation Code to email.
    - Crucial Security Feature: Always return 200 OK to prevent email enumeration.
- Endpoint 2: "/register-verify"
  - Input: Email, Code, RegistrationChallengeToken.
  - Output: If correct, issue a new, expiring "PasswordChallengeToken".
- Endpoint 3: "/register-create"
  - Input: Email, Password, ConfirmPassword, PasswordChallengeToken.
  - Logic: Validate token. Create user via "UserManager".
  - Auto-Login: Call "SignInManager.SignInAsync" upon success.
  - Response: Redirect URL to "/connect/authorize".

## STEP 5: FRONTEND "WIREFRAME" SYSTEM (WebApp)
1. Create a global CSS file using CSS Variables for a "Wireframe" aesthetic.
   - Define "--bg-canvas", "--fg-primary", "--border-style" in ":root".
   - Use "@media (prefers-color-scheme: dark)" to swap variables for system-aware theming.
   - Design should rely on simple lines, borders, and high contrast.
2. Implement a Parallax effect using CSS 3D transforms for specific banners.
3. Install HTMX. Configure the "_Layout.cshtml" to support a "Single Page Application" feel using HTMX swapping.
   - Define a "#modal-container" with a "backdrop-filter: blur(10px)" CSS class for overlays.

## STEP 6: CLIENT-SIDE AUTHENTICATION FLOWS (WebApp)
1. Create "AccountController" (MVC) acting as a BFF (Backend for Frontend).
2. **Login View ("_LoginPartial"):**
   - Initial State: Header "Sign in with", External buttons (Google/GitHub icons, minimal width), "OR" divider, Email Input, "No account? Register" link.
   - Logic: User enters email -> JS calls AuthServer "/api/auth/check-email".
   - Transition: If valid, reveal Password Input + "Sign In" button.
   - UX Requirement: Display a portion of the received challenge token as a "ChallengeKey" for user reference, replacing the "use a different email" link.
   - Handle "htmx:afterSwap" events to re-initialize any Turnstile widgets if present.
3. **Registration View:**
   - Step 1: Form with Email/DOB/Terms. "Continue" button disabled until valid.
   - Step 2: "Silent" submission. Transition to "Enter Code" view.
   - Step 3: Code Input. Must include "Did not receive code? Re-send" link.
   - Step 4: Password Entry (with email as non-editable text above). Client-side validation (jQuery Unobtrusive).
4. **OIDC Handoff:**
   - The WebApp's "Register()" action must pass "prompt=create" in AuthenticationProperties to signal intent.
   - Once local login/register is done, the client redirects to "/connect/authorize".

## STEP 7: FEDERATION & MOCKING (AuthServer)
1. Configure ".AddGoogle()" and ".AddGitHub()" in AuthServer.
2. **External Login Handler:**
   - Use "SignInManager.GetExternalLoginInfoAsync".
   - If new user: Extract email, create "ApplicationUser", "AddLoginAsync", then "SignInAsync".
3. **Mock Auth (Development Only):**
   - Create a Mock OAuth endpoint that opens a Popup Window.
   - Render a fake "Consent Screen".
   - On acceptance, use "window.opener.postMessage" to notify the parent window (WebApp) of the "Success" event, closing the popup and triggering the login completion flow.

## STEP 8: RESOURCE API & CONSUMPTION
1. Configure "ResourceApi" to use "JwtBearer" authentication.
   - Validate Audience ("resource_server") and Issuer ("https://localhost:5001").
   - Enforce Authorization Policy requiring "resource_api" scope.
2. Create a generic VSA feature "Features/Data/GetSecureData" protected by "[Authorize]".
3. **BFF Proxy in WebApp:**
   - Create "[HttpPost] CallApi" action in AccountController.
   - Retrieve Access Token: "await HttpContext.GetTokenAsync("access_token")".
   - Use "IHttpClientFactory" to set Bearer header and proxy request to Port 5003.
   - Return data to view. This prevents leaking tokens to browser JS.
4. **Logout Logic:**
   - Button calls "AccountController.Logout".
   - Action returns "SignOut()" for *both* "CookieAuthenticationDefaults" and "OpenIdConnectDefaults".
   - Redirects to AuthServer "/connect/logout", then back to WebApp home.

## EXECUTION INSTRUCTIONS
- Use ".NET Secret Manager" for all secrets (Client IDs, DB Strings) with placeholders in "appsettings.json".
- Ensure strictly distinct ports (5001, 5002, 5003).
- Verify that the Data Protection Token logic strictly binds to the specific Email to prevent replay attacks.