Create a new .NET 8 solution with three projects: a web browser client named "WebApp" (ASP.NET Core MVC), an identity provider named "AuthServer" (ASP.NET Core Web API), and an auth-protected API named "ResourceApi" (ASP.NET Core Web API). Generate a root .sln file and ensure each project is configured with distinct ports (e.g., 5001, 5002, 5003) in launchSettings.json. The AuthServer will be the sole authority for identity, built using OpenIddict, ASP.NET Core Identity, and Entity Framework Core with a SQLite provider; its initial database schema must be created and managed via EF Core Migrations. Integrate Quartz.NET with OpenIddict for scheduled token pruning. The migration must include tables for ASP.NET Core Identity (like AspNetUsers, including a custom DateOfBirth column) and all OpenIddict entities (like OpenIddictApplications and OpenIddictTokens). Configure the AuthServer for external identity federation using .AddGoogle() and .AddGitHub(). All secrets must be configured for the .NET Secret Manager, with clear placeholders in appsettings.json. Enable Session middleware in the AuthServer to handle the Cloudflare verification state. The WebApp's home page will display two buttons: a login button and a register button. The authentication flow is as follows: 1) A user navigates to the WebApp's domain, which is fronted by Cloudflare. HTTPS redirection is enforced. The WebApp initiates a secure Authorization Code Flow with PKCE and redirects the user to the AuthServer. The WebApp's AccountController will have Login() and Register() actions that return a Challenge() result against the OpenIdConnectDefaults.AuthenticationScheme. The Register() action must pass a prompt=create parameter in the AuthenticationProperties to signal the registration intent to the AuthServer. 2) Before presenting any login options, the AuthServer must first present an interstitial bot-check Cloudflare captcha verification page, which requires the user to successfully complete the captcha widget to proceed. The page should not have its own 'Confirm' button, as the widget will trigger the form post. It should also display the Ray ID sourced from the Cloudflare routed request under the captcha. This should be implemented using a custom middleware in AuthServer that intercepts requests to /connect/authorize, checks for a session flag (e.g., CloudflareVerified), and if missing, redirects to a Cloudflare.cshtml Razor Page. This page will be responsible for rendering the widget and, upon successful POST validation (in OnPostAsync), setting the session flag and redirecting back to the original /connect/authorize URL. 3) After captcha confirmation, the AuthServer displays the initial login page (Login.cshtml). This page will be dynamically controlled by client-side JavaScript. It must default to a 'Sign in' state. This page's 'Sign in' state will show a header "Sign in with", a link "No account? Register", the external provider buttons (Google/GitHub) styled with icons and minimal width, an "OR" divider, and the local email input field with a 'Continue' button. 4) When a user chooses the local login path and enters their email and clicks 'Continue', the client calls a new API endpoint on the AuthServer to check the email's existence. If the email corresponds to a valid user, this endpoint will return a short-lived, single-use login challenge token. The client-side script detects the response and will then dynamically reveal a password input field on the form. Enable CORS on the AuthServer specifically for the WebApp's origin to allow these cross-origin fetch requests. This API endpoint (e.g., /api/auth/check-email) must be part of a new AuthController in AuthServer. The token should be a Data Protection token (not a JWT) to bind it to this specific server. The client-side script will use this token to transition to a 'Password Entry' view. This view must show the user's email as non-editable text, the password input, a 'Sign In' button, and a link at the top to switch to registration. It should also display a portion of the challenge token as a 'ChallengeKey' for user reference, replacing the "use a different email" link. 5) Upon entering the password and submitting, another API endpoint on the AuthServer will be called, receiving the email, password, and the login challenge token. This endpoint must validate the token before attempting to validate the password using ASP.NET Core Identity. If local authentication is successful, the AuthServer proceeds with the standard OpenIddict flow. This second endpoint (e.g., /api/auth/login) will validate the Data Protection token, then use SignInManager.CheckPasswordSignInAsync. If successful, it must not return a token, but instead call SignInManager.SignInAsync to create the local Identity cookie. The API response should then tell the client to redirect to the original /connect/authorize URL, which will now succeed because the user is authenticated. Additionally, clicking the 'No account? Register' link initiates a new user registration flow by switching the client-side view. The registration view (Step 2 of registration) must present a form requesting email, date of birth, and a checkbox to accept terms. The 'Continue' button on this register form will only become active once all fields are validly filled. When submitted, the client will first call the /api/auth/check-email endpoint. If the email is found already registered in the server, it will NOT alert the client and will proceed to the client as if the email is available this is a security feature to not alert attackers of valid emails. serverside If the email is available (action: 'register'), the client will receive a registrationChallengeToken. It will then immediately call a second endpoint (e.g., /api/auth/register-start) with the email, date of birth, and the new token. To prevent email enumeration, this /api/auth/register-start endpoint must always return a 200 OK, even if the email is already taken. The server, upon receiving the initial registration data, will check the email: if the email is available, it sends a confirmation code to that email; if the email is taken, it sends a 'your account already exists' message with a password reset link to that email. The client will always transition dynamically to a view asking for a confirmation code (Step 3 of registration), providing no immediate feedback on whether the email is already in use to the browser client, who will "find out" the result of the email query in the email sent. The registration flow for an existing user ends here, as the password reset system is not being implemented yet. The new user continuing enters the received confirmation code from the email into the client form. This view must include a "Did not receive code? Re-send" link. The client sends this code to the server for validation along with the registration challenge token. If the token and code are correct, the server responds with a new, expiring password challenge token. This token allows the client to display the final registration step (Step 4 of registration): a form to enter and confirm a password, with the email displayed as a non-editable string above. This password and confirm password are validated client-side using jQuery Unobtrusive Validation, and if they match, the email, password along with the password challenge token is sent to the server. The server validates the token and, if successful, creates the new user account using ASP.NET Core Identity's standard mechanisms. The specific server-side implementation of SRP6 for storing a verifier and salt instead of the password itself is out of scope for this prompt. Once a user successfully registers, they are considered logged in, and the process continues to step 7. The /api/auth/register-create endpoint, upon successful user creation, must also call SignInManager.SignInAsync to create the Identity cookie and respond with a redirect URL to /connect/authorize, just like the login flow. If the user chooses an external OAuth provider from the initial login page, this is handled not by the API controller, but by the Login.cshtml PageModel's OnPostExternalLogin handler, which returns a ChallengeResult that orchestrates a second redirect to the selected third-party provider. 6) Upon successful third-party authentication, the user is returned to the AuthServer. This callback should be handled by a dedicated ExternalController (or ExternalLogin PageModel). It will use SignInManager.GetExternalLoginInfoAsync, and then SignInManager.ExternalLoginSignInAsync. If the user is new, it will extract the email claim, create a new ApplicationUser, and use UserManager.AddLoginAsync before finally calling SignInManager.SignInAsync. 7) After step 5 or 6, the user (now authenticated with an Identity cookie) is redirected back to /connect/authorize. The AuthorizationController's Authorize action will detect the cookie, create a ClaimsPrincipal for OpenIddict, and SignIn the principal to the OpenIddict scheme, which generates the authorization code and redirects to the WebApp. 8) The WebApp's backend exchanges this authorization code for JWT ID and access tokens from the AuthServer. 9) After the WebApp backend receives and validates the tokens, it creates a local session cookie and redirects the user to a [Authorize] protected "/Account" page. On this page, display the user's claims from the ID token and make an authenticated request to a protected endpoint on the ResourceApi, displaying the API's successful response. The ResourceApi must verify the 'resource_api' scope using a defined Authorization Policy, ensuring the WebApp requested this scope. This should be implemented with a JavaScript function on the page that calls a [HttpPost] action in the WebApp's AccountController (e.g., CallApi). This backend action will retrieve the stored access token (await HttpContext.GetTokenAsync("access_token")), use IHttpClientFactory to set the Bearer header, and proxy the call to the ResourceApi. This prevents leaking the access token to the browser's JavaScript context. Finally, implement a secure logout button added to the account page in the WebApp that clears the local cookie and initiates a redirect to the AuthServer's end-session endpoint to terminate the central SSO session. The Logout action in WebApp's AccountController must return a SignOut() result for both the CookieAuthenticationDefaults.AuthenticationScheme and the OpenIdConnectDefaults.AuthenticationScheme. This triggers the redirect to AuthServer's /connect/logout endpoint, which in turn signs out of the Identity cookie and redirects back to the WebApp's configured PostLogoutRedirectUri, returning the user to the initial page with login/register button to signal the logout is complete. The implementation is complete once only the third-party client secrets/API keys need to replace placeholders.